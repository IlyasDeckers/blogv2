[{"content":"Introduction: What is the Single Action Handler Pattern? In modern PHP web development, the Single Action Handler (often implemented as an Invokable Controller or specifically as a PSR-15 Request Handler) represents a shift towards more focused, decoupled, and testable code, especially for APIs and specific web actions.\nThis pattern moves away from traditional Model-View-Controller (MVC) structures where a single Controller class might handle numerous related routes via multiple methods (e.g., UserController with index(), show(), store(), etc.).\nInstead, a Single Action Handler is a class dedicated exclusively to processing the logic for one specific route or endpoint. It achieves this typically through:\nImplementing PHP\u0026rsquo;s magic __invoke() method, allowing the class instance to be treated as the action itself. Implementing the Psr\\Http\\Server\\RequestHandlerInterface, which defines a handle(ServerRequestInterface $request): ResponseInterface method â€“ the standard defined by PSR-15. This article explores this pattern, its benefits, the crucial role of PSR standards, and how it can be implemented effectively (and with varying degrees of native support) in popular PHP frameworks like Mezzio, Symfony, and Laravel.\nExample:\nTraditional Multi-Action Controller:\n1 2 3 4 5 6 7 8 9 10 // UserController.php class UserController { public function show(int $id) { /* ... */ } public function store(Request $request) { /* ... */ } // ... other methods ... } // routes.php Route::get(\u0026#39;/users/{id}\u0026#39;, [UserController::class, \u0026#39;show\u0026#39;]); Route::post(\u0026#39;/users\u0026#39;, [UserController::class, \u0026#39;store\u0026#39;]); Single Action Handler Pattern (Conceptual):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ShowUserAction.php (or ShowUserController.php) class ShowUserAction { public function __invoke(int $id) { /* Logic for showing a user */ } } // StoreUserAction.php (or StoreUserController.php) class StoreUserAction { public function __invoke(Request $request) { /* Logic for storing a user */ } } // routes.php Route::get(\u0026#39;/users/{id}\u0026#39;, ShowUserAction::class); Route::post(\u0026#39;/users\u0026#39;, StoreUserAction::class); Why Use This Pattern? The Rationale Adopting the single action handler pattern brings significant advantages:\nSingle Responsibility Principle (SRP): Each class does exactly one thing. This drastically improves clarity, making code easier to understand, modify safely, and debug. Enhanced Testability: Unit testing becomes much simpler. Smaller classes have fewer dependencies to mock, and the scope of each test is clearly defined. Improved Organization: Prevents \u0026ldquo;fat controllers.\u0026rdquo; Code can be neatly organized by feature or domain slice, leading to a more maintainable structure, especially in large applications. Increased Readability: The class name itself often describes the action (e.g., ProcessPaymentHandler, GetUserApiEndpoint). The single handle() or __invoke() method contains all relevant logic. Precise Dependency Management: Only dependencies needed for that specific action are injected, leading to cleaner constructors and more efficient resource usage. Reduced Cognitive Load: Developers can focus entirely on the task of a single endpoint without the mental overhead of unrelated actions in the same file. The Importance of PSR Standards For single Action Handles Understanding PSR (PHP Standard Recommendations) is crucial for appreciating the full benefits of modern PHP development and patterns like PSR-15 Request Handlers. PSRs are specifications published by the PHP Framework Interop Group (PHP-FIG), comprised of members from various major PHP projects. Their goal is to promote interoperability and standardization across the PHP ecosystem.\nKey PSRs for Web Development:\nPSR-7 (HTTP Message Interfaces): Defines standard interfaces for HTTP request (RequestInterface, ServerRequestInterface) and response (ResponseInterface) objects, along with related objects like URIs and streams. A key feature is immutability, which prevents unexpected side effects when messages are passed through multiple layers (like middleware). PSR-15 (HTTP Server Request Handlers \u0026amp; Middleware): Builds upon PSR-7. RequestHandlerInterface: Defines a standard way to process a PSR-7 request and return a PSR-7 response (our Single Action Handler!). MiddlewareInterface: Defines a standard interface for middleware components that process requests before or after a handler (or other middleware). Why Adhering to PSR Standards (like PSR-7/15) is a Good Idea:\nInteroperability: This is the primary driver. Code written against PSR interfaces (handlers, middleware, HTTP clients, factories) can often be used across different frameworks and libraries that also adhere to those standards. You can mix and match components from different vendors. Reduced Vendor Lock-In: By relying on community standards rather than framework-specific abstractions for core functionalities like HTTP handling, your application becomes less tied to a single framework\u0026rsquo;s ecosystem, making future migrations or integrations potentially easier. Reusability: Logic encapsulated in PSR-15 handlers or middleware can be more easily reused across different projects, even if those projects use different underlying frameworks (provided they support PSR-15). Consistency \u0026amp; Predictability: Standard interfaces mean developers encounter familiar patterns across different projects and libraries. This reduces the learning curve and makes codebases easier to understand and contribute to. Modern Best Practices: PSR-7\u0026rsquo;s immutability and PSR-15\u0026rsquo;s clear definition of middleware and handlers encourage decoupled, layered application design, which is widely considered a best practice for building robust web applications. Future-Proofing: Basing core application logic on community-agreed standards makes it less vulnerable to breaking changes within a specific framework\u0026rsquo;s internal abstractions. Easier Package Development: If you\u0026rsquo;re creating reusable packages (e.g., authentication middleware, API validation logic), targeting PSR interfaces makes them instantly usable in a much wider range of applications. Relevance to Handlers: Using PSR-15 RequestHandlerInterface directly ties your core request-handling logic to these community standards, unlocking the benefits of interoperability, reusability, and consistency. Frameworks that embrace these standards natively often provide a smoother path to achieving these advantages.\nImplementation Across Frameworks Frameworks vary in their native support for PSR-15 handlers.\nPSR-15 Native Frameworks (e.g., Mezzio): Use PSR-15 handlers as the fundamental way to process requests. Full-Stack Frameworks (e.g., Symfony, Laravel): Primarily use their own abstractions but provide mechanisms (bridges, extension points) to integrate PSR-15 handlers, requiring varying levels of effort. 1. Middleware Frameworks (PSR-15 Native - Mezzio Example) Frameworks like Mezzio (formerly Zend Expressive) are built from the ground up around PSR-7 and PSR-15. Using single-action RequestHandlerInterface implementations is the standard, idiomatic way.\nCore Concept: Requests flow through a PSR-15 middleware pipeline, ending at a route-specific RequestHandlerInterface. Example Implementation (Mezzio): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;?php // src/App/Handler/GetUserHandler.php declare(strict_types=1); namespace App\\Handler; use App\\Repository\\UserRepositoryInterface; use Laminas\\Diactoros\\Response\\JsonResponse; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class GetUserHandler implements RequestHandlerInterface { private UserRepositoryInterface $userRepository; public function __construct(UserRepositoryInterface $userRepository) { $this-\u0026gt;userRepository = $userRepository; } public function handle(ServerRequestInterface $request): ResponseInterface { // Get route parameter (assuming router middleware added it as attribute) $userId = (int) $request-\u0026gt;getAttribute(\u0026#39;id\u0026#39;); $user = $this-\u0026gt;userRepository-\u0026gt;findById($userId); if (!$user) { return new JsonResponse([\u0026#39;error\u0026#39; =\u0026gt; \u0026#39;User not found\u0026#39;], 404); } // Assuming User object has a suitable method for array conversion return new JsonResponse($user-\u0026gt;toArray()); } } Routing (e.g., in config/routes.php) 1 $app-\u0026gt;get(\u0026#39;/api/users/{id:\\d+}\u0026#39;, App\\Handler\\GetUserHandler::class, \u0026#39;api.user.get\u0026#39;); Pros (Mezzio/PSR-15 Native): Pure PSR Adherence: Natively uses PSR-7/15, maximizing interoperability and benefits of the standards. No bridging needed for core HTTP handling. Minimalism \u0026amp; Performance: Very lean core, potentially high performance. Maximum Flexibility \u0026amp; Decoupling: Full control over components; promotes decoupled design. Cons (Mezzio/PSR-15 Native): More Initial Setup: Requires assembling the application stack (router, container, ORM, etc.). Smaller Framework-Specific Ecosystem: Fewer Mezzio-specific bundles compared to Symfony/Laravel (though any standard PHP/PSR package works). 2. Symfony: Achieving PSR-15 Compliance Symfony is highly flexible and can work cleanly with PSR-15 handlers, though its core uses HttpFoundation.\nOption 1: Adapter Pattern (The Basic Approach) Concept: Create a standard Symfony controller (__invoke) that acts as a bridge. It receives the HttpFoundation\\Request, converts it to PSR-7 ServerRequestInterface (using symfony/psr-http-message-bridge), calls your actual RequestHandlerInterface, converts the PSR-7 ResponseInterface back to HttpFoundation\\Response, and returns it. Pros: Explicit, relatively easy to understand for a single handler. Cons: Significant boilerplate - requires one adapter class per PSR-15 handler. Feels cumbersome. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;?php namespace App\\Controller\\Api\\Orders; use App\\Handler\\ProcessOrderHandler; use Symfony\\Bridge\\PsrHttpMessage\\HttpFoundationFactoryInterface; use Symfony\\Bridge\\PsrHttpMessage\\HttpMessageFactoryInterface; use Symfony\\Component\\HttpFoundation\\Request; // Symfony Request use Symfony\\Component\\HttpFoundation\\Response; // Symfony Response use Symfony\\Component\\Routing\\Annotation\\Route; class ProcessOrderAdapterAction { private HttpMessageFactoryInterface $psrHttpFactory; private HttpFoundationFactoryInterface $httpFoundationFactory; private ProcessOrderHandler $handler; public function __construct( HttpMessageFactoryInterface $psrHttpFactory, HttpFoundationFactoryInterface $httpFoundationFactory, ProcessOrderHandler $handler // Autowired by Symfony DI ) { $this-\u0026gt;psrHttpFactory = $psrHttpFactory; $this-\u0026gt;httpFoundationFactory = $httpFoundationFactory; $this-\u0026gt;handler = $handler; } #[Route(\u0026#39;/api/orders\u0026#39;, name: \u0026#39;api_order_process\u0026#39;, methods: [\u0026#39;POST\u0026#39;])] public function __invoke(Request $request): Response { // 1. Convert Symfony Request -\u0026gt; PSR-7 Request $psrRequest = $this-\u0026gt;psrHttpFactory-\u0026gt;createRequest($request); // 2. Call the actual PSR-15 Handler $psrResponse = $this-\u0026gt;handler-\u0026gt;handle($psrRequest); // 3. Convert PSR-7 Response -\u0026gt; Symfony Response $response = $this-\u0026gt;httpFoundationFactory-\u0026gt;createResponse($psrResponse); // 4. Return Symfony Response return $response; } } Option 2: Centralized Listener (The Cleaner Approach)\nConcept: Leverage Symfony\u0026rsquo;s Kernel Events. Create an Event Listener for the kernel.controller event. This listener checks if the controller resolved by the router implements RequestHandlerInterface. If it does, the listener takes over: it uses the PSR-7 bridge to convert the request, executes the handler\u0026rsquo;s handle method, converts the response back, and sets it directly on the event ($event-\u0026gt;setResponse()), bypassing Symfony\u0026rsquo;s standard controller execution. Detailed Steps: Install bridge: composer require symfony/psr-http-message-bridge nyholm/psr7 (Nyholm is a popular PSR-7 implementation). Create your PSR-15 handler class (implementing RequestHandlerInterface). Ensure it\u0026rsquo;s registered as a service. Create an Event Listener class implementing EventSubscriberInterface or listening to KernelEvents::CONTROLLER. Inject HttpMessageFactoryInterface and HttpFoundationFactoryInterface (from the bridge) into the listener. In the listener method: Get controller from $event-\u0026gt;getController(). Check if it implements RequestHandlerInterface. If yes: Convert $event-\u0026gt;getRequest() -\u0026gt; PSR-7 Request. Call $controller-\u0026gt;handle($psr7Request). Convert PSR-7 Response -\u0026gt; Symfony Response. Call $event-\u0026gt;setResponse($symfonyResponse). Register the listener with appropriate priority. Route directly to the service ID or FQCN of your PSR-15 handler class. Pros: Eliminates adapter boilerplate. Centralizes bridging logic. Allows clean routing directly to PSR-15 handlers. Promotes PSR standard usage cleanly within Symfony. Cons: Requires deeper understanding of Symfony\u0026rsquo;s Kernel Events. The listener becomes a critical piece of infrastructure that needs careful testing. Overall Symfony \u0026amp; PSR: Symfony offers excellent tools and flexibility (psr-http-message-bridge, Kernel Events) to achieve clean PSR-15 integration via the listener approach. While not PSR-native at its core HTTP layer, its robust component system and extensibility make it a strong choice for developers wanting a full-stack framework that respects and facilitates PSR standard adherence.\n3. Laravel: Achieving PSR-15 Compliance Laravel prioritizes developer experience and convention. While it uses HttpFoundation internally and doesn\u0026rsquo;t natively execute PSR-15 handlers, integration is possible.\nOption 1: Adapter Pattern (The Basic Approach) Concept: Similar to Symfony\u0026rsquo;s adapter - create an invokable Laravel controller (__invoke) that uses the PSR-7 bridge (included via dependencies) to convert the Illuminate\\Http\\Request, call the PSR-15 handler, and convert the PSR-7 response back to a Laravel-compatible response. Requires PSR-7 implementation like Nyholm and manual factory setup. Pros: Explicit. Cons: Significant boilerplate per handler. Feels unnatural in the Laravel ecosystem. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;?php namespace App\\Http\\Controllers\\Api\\Order; use App\\Handler\\ProcessOrderHandler; use Illuminate\\Http\\Request; use Psr\\Http\\Message\\ResponseInterface as PsrResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface as PsrServerRequestInterface; use Symfony\\Bridge\\PsrHttpMessage\\Factory\\HttpFoundationFactory; use Symfony\\Bridge\\PsrHttpMessage\\Factory\\PsrHttpFactory; // Use appropriate factories - Laravel includes the bridge, but you might need to wire factories // Usually requires Nyholm PSR-7 implementation `composer require nyholm/psr7` // and `composer require symfony/psr-http-message-bridge` class ProcessOrderAdapterController { private ProcessOrderHandler $handler; private PsrHttpFactory $psrHttpFactory; private HttpFoundationFactory $httpFoundationFactory; public function __construct(ProcessOrderHandler $handler) { $this-\u0026gt;handler = $handler; // Manually create factories or inject them if configured in service container // Requires PSR-7 implementation (like Nyholm) to be available $psr17Factory = new \\Nyholm\\Psr7\\Factory\\Psr17Factory(); $this-\u0026gt;psrHttpFactory = new PsrHttpFactory($psr17Factory, $psr17Factory, $psr17Factory, $psr17Factory); $this-\u0026gt;httpFoundationFactory = new HttpFoundationFactory(); } /** * Handle the incoming request. */ public function __invoke(Request $request) // Receives Laravel Request { // 1. Convert Laravel Request -\u0026gt; PSR-7 Request $psrRequest = $this-\u0026gt;psrHttpFactory-\u0026gt;createRequest($request); // 2. Call the actual PSR-15 Handler $psrResponse = $this-\u0026gt;handler-\u0026gt;handle($psrRequest); // 3. Convert PSR-7 Response -\u0026gt; Symfony/Laravel Response $response = $this-\u0026gt;httpFoundationFactory-\u0026gt;createResponse($psrResponse); // 4. Return Laravel compatible Response return $response; } } Option 2: Centralized Middleware (The Cleaner Approach) Concept: Create a custom Laravel Middleware. This middleware checks if the controller class resolved by the router for the current route implements RequestHandlerInterface. If it does, the middleware takes over: it instantiates the handler (via container), performs the Request/Response bridging using PSR-7 factories, executes the handler\u0026rsquo;s handle method, and returns the converted response directly, bypassing Laravel\u0026rsquo;s standard controller dispatch ($next($request) is skipped). Detailed Steps: Install PSR-7 implementation: composer require nyholm/psr7. Ensure bridge is available (usually is). Create your PSR-15 handler class. Create a Middleware class (e.g., HandlePsr15Requests). Inject or create PSR-7 bridge factories within the middleware. In the handle($request, Closure $next) method: Inspect $request-\u0026gt;route()-\u0026gt;getController() or $request-\u0026gt;route()-\u0026gt;getActionName() to find the target handler class. Use Reflection or the container to check if it implements RequestHandlerInterface. If yes: Instantiate handler via app()-\u0026gt;make(). Convert Illuminate\\Http\\Request -\u0026gt; PSR-7 Request. Call handle(). Convert PSR-7 Response -\u0026gt; Laravel Response. return $laravelResponse; If no: return $next($request); Register the middleware globally or in a specific route group (e.g., api) in app/Http/Kernel.php. Route directly to the FQCN of your PSR-15 handler class. Pros: Eliminates adapter boilerplate. Centralizes bridging logic. Allows routing directly to PSR-15 handlers. Cons: Middleware becomes complex and critical. Requires careful handling of route information and potential pipeline order issues. Setting up PSR-7 factories might need a Service Provider. Works slightly \u0026ldquo;against the grain\u0026rdquo; of Laravel\u0026rsquo;s typical controller flow. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public function handle(Request $request, Closure $next) { $route = $request-\u0026gt;route(); $controllerAction = $route-\u0026gt;getActionName(); // Might be \u0026#39;ClassName\u0026#39; or \u0026#39;ClassName@method\u0026#39; // Need a reliable way to get the target class name. // $controllerAction could be \u0026#39;App\\Handler\\MyPsr15Handler\u0026#39; if routed directly to class // Or sometimes it might be complex, need robust parsing if method is involved. // Let\u0026#39;s assume direct class routing: $controllerClass = is_string($controllerAction) \u0026amp;\u0026amp; class_exists($controllerAction) ? $controllerAction : null; // Check if the resolved class exists and implements the interface if ($controllerClass \u0026amp;\u0026amp; (new \\ReflectionClass($controllerClass))-\u0026gt;implementsInterface(\\Psr\\Http\\Server\\RequestHandlerInterface::class)) { // Instantiate the handler via the container to resolve dependencies $psr15Handler = app()-\u0026gt;make($controllerClass); // Get bridge factories (configure in a Service Provider or create manually) // Requires PSR-7 Implementation (e.g., composer require nyholm/psr7) $psr17Factory = new \\Nyholm\\Psr7\\Factory\\Psr17Factory(); $psrHttpFactory = new \\Symfony\\Bridge\\PsrHttpMessage\\Factory\\PsrHttpFactory($psr17Factory, $psr17Factory, $psr17Factory, $psr17Factory); $httpFoundationFactory = new \\Symfony\\Bridge\\PsrHttpMessage\\Factory\\HttpFoundationFactory(); // Convert Laravel Request -\u0026gt; PSR-7 Request $psrRequest = $psrHttpFactory-\u0026gt;createRequest($request); // Execute the PSR-15 Handler $psrResponse = $psr15Handler-\u0026gt;handle($psrRequest); // Convert PSR-7 Response -\u0026gt; Laravel Response $response = $httpFoundationFactory-\u0026gt;createResponse($psrResponse); // Return the response *directly*, bypassing $next() and standard controller dispatch return $response; } // If not a PSR-15 handler route, proceed normally return $next($request); } Overall Laravel \u0026amp; PSR: Laravel can be made to work with PSR-15 handlers via middleware, significantly cleaning up the adapter approach. However, compared to Symfony\u0026rsquo;s kernel events or Mezzio\u0026rsquo;s native support, it feels less integrated. Laravel\u0026rsquo;s strength lies in its opinionated, rapid development workflow using its native components (Eloquent, Blade, Facades). Pushing for strict PSR-15 handler compliance requires bypassing some of that core flow. General Pros and Cons of the Single Action Handler Pattern (Summary) Pros: SRP, Testability, Organization, Readability, Precise Dependencies. Cons: Potentially more files, requires conscious architectural choice.\nWhen to Use This Pattern API endpoints. Single, distinct web actions (form processing, etc.). When controller actions become complex. To enforce SRP and improve testability. As the default in PSR-15 native frameworks. Conclusion \u0026amp; Framework Choice Considerations The Single Action Handler pattern, especially when implemented using the PSR-15 RequestHandlerInterface, represents a powerful approach for building modern, maintainable, and testable PHP applications. Adhering to PSR standards like PSR-7 and PSR-15 brings significant benefits in interoperability, reusability, and future-proofing your codebase.\nWhen choosing a framework with PSR adherence in mind:\nFor Native PSR-15/7 Experience: If maximizing interoperability and working directly with PSR standards at the core HTTP layer is your highest priority, a middleware-centric framework like Mezzio is designed specifically for this. It offers the cleanest, most direct path to leveraging PSR-7/15. For Full-Stack Power with PSR Flexibility: If you require a comprehensive framework with a vast ecosystem, but still want the ability to cleanly integrate and prioritize PSR-15 handlers, Symfony provides excellent flexibility. Its robust DI container, component system, and kernel events (allowing the centralized listener approach) make it a strong contender for building large applications that adhere well to PSR standards with reasonable effort. For Rapid Development \u0026amp; DX Prioritizing Framework Conventions: If top development speed, an integrated ecosystem, and convention over configuration are paramount, Laravel excels. While achieving strict PSR-15 handler compliance requires more deliberate effort (via the centralized middleware approach, working slightly against the native flow), it\u0026rsquo;s possible. However, the main draw of Laravel often lies in embracing its way of doing things. ","date":"2025-04-14T00:00:00Z","permalink":"https://ilyasdeckers.ody.dev/p/single-action-handlers/","title":"Single Action Handlers in PHP Frameworks"},{"content":"Introduction Modern software development increasingly emphasizes code robustness, maintainability, and catching errors early. Type safety plays a crucial role in achieving these goals. Teams often face a choice: migrate to a language with built-in static typing or enhance their existing dynamically typed language (like PHP) with powerful static analysis tools.\nThis document compares these two approaches:\nNative Statically Typed Languages: Languages where type checking is a fundamental, mandatory part of the compiler (e.g., Go, C#, Rust, Scala, Java, TypeScript*). PHP + Static Analysis Tools: Using PHP (which is dynamically typed at its core) augmented with tools like PHPStan or Psalm to perform type checking before runtime. (*Note: TypeScript compiles to JavaScript but provides static typing during development and compilation).\nApproach 1: Native Statically Typed Languages Definition These languages require type information to be known at compile time. The compiler rigorously checks type compatibility throughout the codebase before producing an executable or intermediate code.\n(Examples: Go, C#, Rust, Scala, Java)\nMechanism Type checking is inherent to the language and compiler. It\u0026rsquo;s a mandatory step to produce a runnable program. Errors found by the compiler prevent compilation altogether. Pros Strong Compile-Time Guarantees: Catches a wide range of type errors, null pointer issues (depending on language features like null safety), and API contract violations before the code can even run. High Runtime Safety: The compiled code benefits from the guarantees established at compile time, leading to fewer unexpected runtime type errors. Excellent Refactoring Safety: The compiler immediately flags issues arising from code changes (e.g., changing a function signature). Performance Potential: Type information allows compilers to perform significant optimizations (Ahead-of-Time compilation), often leading to better runtime performance compared to interpreted languages. Clear Contracts: Types serve as enforced documentation, making interfaces and data structures explicit. Rich Native Type Systems: Often include advanced features like generics, interfaces, traits, enums, etc., as core language constructs. Mature Tooling \u0026amp; IDE Support: Excellent code completion, error highlighting, and refactoring tools based directly on the language\u0026rsquo;s type system. Cons Steeper Learning Curve: Requires learning a new language syntax, standard library, ecosystem, build tools, and potentially different programming paradigms (e.g., Go\u0026rsquo;s concurrency, Rust\u0026rsquo;s ownership). Migration Effort: Moving an existing PHP codebase requires a significant rewrite. Initial Strictness: Can feel less flexible or more verbose initially compared to dynamic languages. Compilation Time: Can be a factor in development cycles for very large projects (though often offset by finding errors earlier). Approach 2: PHP + Static Analysis Tools Definition This involves writing standard PHP code, leveraging its native type hinting features (scalar types, return types, property types, union types, etc.), and potentially adding detailed PHPDoc annotations. External tools then analyze this code without running it.\n(Examples: PHP with PHPStan or Psalm)\nMechanism Type checking is performed by an external tool, separate from the PHP interpreter itself. It analyzes code based on native type hints (int, string, ?User, int|string) and detailed PHPDoc annotations (@var, @param, @return, @template, array{...}). Analysis is typically run manually, via commit hooks, or in a CI/CD pipeline. It does not prevent PHP from attempting to run code with type errors if the analysis step is skipped. Pros Familiar Ecosystem: Allows teams to stay within the PHP language, leveraging existing knowledge, frameworks (Laravel, Symfony, etc.), libraries, and infrastructure. Lower Initial Learning Curve: Focuses on learning the static analysis tool and writing better-typed PHP, rather than an entirely new language. Gradual Adoption: Tools like PHPStan/Psalm have configurable levels and baseline features, allowing teams to introduce type checking incrementally, focusing on new code first if needed. Catches Most Type Errors: When configured well and used diligently, these tools catch a vast majority of type-related errors, nullability issues, and other potential bugs before runtime. Improved Code Quality: Significantly enhances PHP code\u0026rsquo;s readability, maintainability, and reliability. Safer Refactoring within PHP: Provides much greater confidence when making changes to existing PHP code. Excellent IDE Integration: Plugins provide real-time feedback directly in the editor (VS Code, PhpStorm). Cons No Runtime Guarantee: PHP\u0026rsquo;s core execution model remains dynamically typed. If the static analysis step is skipped, incomplete, or if external dependencies violate contracts in unexpected ways, runtime type errors are still possible. The guarantee comes from the process of using the tool, not the language runtime itself. Dependency on Tooling \u0026amp; Annotations: The effectiveness relies heavily on the quality of type hints, the thoroughness of PHPDoc annotations (especially for generics or complex array shapes), and the configuration level of the analysis tool. Potential Verbosity (PHPDoc): Complex type scenarios might require verbose PHPDoc blocks where native PHP types are insufficient. (PHP continues to improve its native type system, reducing this over time). Analysis Time: Can add time to CI builds or pre-commit checks for large projects. No Inherent Performance Gain: Does not fundamentally change PHP\u0026rsquo;s runtime performance characteristics (unlike compilation in many static languages). Key Differences Summarized Feature Native Static Language (Go, C#, Rust\u0026hellip;) PHP + Static Analysis (PHPStan/Psalm) Core Nature Statically Typed Dynamically Typed (at runtime) Enforcement By Compiler (Built-in, Mandatory) External Tool (Process-driven) Error Detection Compile-Time Analysis-Time (Pre-Runtime) Runtime Safety Very High (Language Guarantee) High (If analysis is run \u0026amp; complete) Type System Used Native Language Features Native PHP Types + PHPDoc Annotations Performance Often Higher (AOT Optimizations) Standard PHP Performance Learning Curve Higher (New Language/Ecosystem) Lower (Enhance Existing Skills) Adoption Scope Full Language Switch Incremental / Gradual Possible Flexibility Lower (Compiler Strictness) Higher (PHP Core Dynamism) When to Choose Which Approach? Choose Native Static Languages if:\nPerformance, concurrency, or compile-time memory safety are top priorities. Starting a new project where the team is willing and able to learn a new ecosystem. The specific strengths of a language align well with the project domain (e.g., systems work for Rust, high-concurrency services for Go, large enterprise apps for C#/Java). You require the strongest possible runtime guarantees enforced by the language itself. Choose PHP + Static Analysis if:\nYou need to improve the quality and maintainability of an existing PHP codebase. Your team wants to remain within the PHP ecosystem (frameworks, libraries, developer skills). A lower initial learning curve and gradual adoption are preferred. You value PHP\u0026rsquo;s flexibility and rapid development cycle but want significantly increased safety. You accept that the ultimate runtime safety relies on the process of using the tools correctly, rather than being inherent in the PHP runtime itself. Conclusion Both approaches offer significant advantages over traditional, untyped dynamic language development. Native statically typed languages provide the strongest compile-time and runtime guarantees at the cost of a higher learning curve and migration effort. Enhancing PHP with powerful static analysis tools like PHPStan or Psalm offers a pragmatic path to achieving vastly improved type safety, code quality, and maintainability while leveraging existing skills and ecosystems, making it an excellent choice for many PHP teams.\n","date":"2025-04-13T00:01:00Z","permalink":"https://ilyasdeckers.ody.dev/p/php-static-analysis-vs-native-statically-typed-languages/","title":"PHP + Static Analysis vs. Native Statically Typed Languages"},{"content":"Letâ€™s dive into Swooleâ€™s most extreme, undocumented, and borderline-insane optimizations and toolsâ€”the kind of stuff used by Alibaba, Tencent, and Bytedance at scale.\nProfile-Guided Optimization SWOOLE_HAVE_PGO\nWhat It Is A compile-time technique where Swoole is first profiled under real workload (e.g., 100K RPS), then recompiled with optimizations tailored to that exact usage pattern.\nHow It Works Instrumentation Phase:\n1 2 ./configure --enable-swoole --enable-gcov make \u0026amp;\u0026amp; make test Runs benchmarks while collecting branch prediction stats, cache misses, hot functions. Optimization Phase:\n1 2 ./configure --enable-swoole --with-pgo make \u0026amp;\u0026amp; make install GCC/Clang rewrites hot paths (e.g., inlining coroutine switches). Performance Gains ~15-25% faster coroutine scheduling. L1/L2 cache misses reduced by up to 40%. Best for: High-frequency trading bots. API gateways (e.g., JSON/Protobuf parsing). The Catch Requires real traffic to profile (no synthetic benchmarks). Breaks if workload changes (must re-profile). Debugging Coroutine Hell --enable-swoole-fiber-sanitizer\nWhat It Is A runtime memory debugger for Swoole coroutines, detecting:\nUse-after-free in coroutine stacks. Memory leaks in go() closures. Race conditions in shared globals. How to Use It Compile Swoole in debug mode: 1 ./configure --enable-swoole --enable-debug --enable-swoole-fiber-sanitizer Run your app: 1 USE_ZEND_ALLOC=0 php -d swoole.fiber_sanitizer=1 your_app.php Logs stack traces of leaks/crashes. Who Needs This? Devs debugging \u0026ldquo;phantom\u0026rdquo; segfaults in coroutines. Teams using global $db in workers (you monsters). The Dark Side ~10x slower (only for debugging). Canâ€™t run with Valgrind (they fight over memory hooks). Bytedanceâ€™s 10M+ Keep-Alive Patch The Problem Swooleâ€™s default epoll event loop struggles past ~1M connections due to:\nO(n) socket fd scanning. Kernel accept() throttling. Their Solution SO_REUSEPORT + Lock-Free Accept:\nMultiple workers compete for new connections (no thundering herd). Uses eBPF to bypass accept() (directly assign fds to workers). Custom epoll Patch:\nReplaces EPOLL_CTL_ADD with EPOLL_CTL_MOD batching. Saves ~7Âµs per connection. Zero-Copy TLS:\nOpenSSL bypassed for static certs (TLS 1.3 only). Saves 1 full RTT per handshake. Performance 10M concurrent connections on a single 32-core AWS c6gn.metal. 3M TLS handshakes/sec (with their modified OpenSSL). How to Try It Their fork is closed-source, but you can approximate it with: 1 ./configure --enable-swoole --with-openssl-dir=/path/to/custom-openssl And in php.ini: 1 2 swoole.reuse_port=1 swoole.enable_unsafe_epoll=1 ; Not for production! Final Thoughts These are weapons-grade optimizationsâ€”most projects donâ€™t need them, but if youâ€™re pushing Swoole to its absolute limits, theyâ€™re the difference between \u0026ldquo;fast\u0026rdquo; and \u0026ldquo;WTF-fast\u0026rdquo;.\nWant to go even deeper?:\n--enable-swoole-io_uring (Linux 5.6+ only, replaces epoll). Swooleâ€™s secret dtrace probes (for kernel-level profiling). How WeChat uses Swoole as a TCP-to-HTTP/3 translator. The rabbit hole never ends. ðŸš€\n","date":"2024-06-21T00:00:00Z","permalink":"https://ilyasdeckers.ody.dev/p/swoole-undocumented-features-pt1/","title":"Swoole undocumented features pt.1"},{"content":"A common pattern you see in Vue is calling a function on created, then watch a property for changes and recall that function. Whilst this is not a bad pattern, I will show you a quick tip how you can improve this code.\n1 2 3 4 5 6 7 8 created () { this.fetchUsers(); } watch: { searchText () { this.fetchUsers(); }, } Did you know that a watcher accepts method names, it can be a string referencing the function. A watcher does not have to be a function. This can be found in the documentation but is easy to miss. We can rewrite the watcher from before like this.\n1 2 3 watch: { searchText: \u0026#39;fetchUsers\u0026#39;, } Another neat feature in Vue watchers is immediate: true. This calls the function specified on the watcher on the creation of the component. Before we can use this we need to adjust the watchers, we create an object for that watcher like this.\n1 2 3 4 5 6 watch: { searchText: { handler: \u0026#39;fetchUsers\u0026#39;, immediate: true, }, } As you can see we specified our function, as a string reference, as a handler and used immediate true. This watcher does exactly the same as the first code example of this post with less code. Fetch on created, then watch.\n","date":"2018-05-12T00:00:00Z","image":"https://ilyasdeckers.ody.dev/p/vue-fetch-on-created-then-watch/cover_hu_e95a4276bf860a84.jpg","permalink":"https://ilyasdeckers.ody.dev/p/vue-fetch-on-created-then-watch/","title":"Vue Quicktip - Fetch on Created, Then Watch"},{"content":"The event bus / publish-subscribe pattern, despite the bad press it sometimes gets, is still an excellent way of getting unrelated sections of your application to talk to each other. But wait! Before you go waste your time on another library, why not use Vueâ€™s powerful built-in event bus?\nCreating the event bus The first thing youâ€™ll need to do is create the event bus and make the bus available to each Vue instance by defining them on the prototype.\n1 2 3 4 5 Object.defineProperty(Vue.prototype, \u0026#39;$bus\u0026#39;, { get () { return this.$root.bus } }) In your Vue component where you want to receive on the $bus put the following code. This listens to incoming requests send over the event bus.\n1 2 3 4 5 6 mounted () { this.$bus.$on(\u0026#39;funcName\u0026#39;, data =\u0026gt; { // do something }) } To trigger the defined event you simply use the following on any of your Vue components.\n1 2 this.$bus.$emit(\u0026#39;funcName\u0026#39;, data) Use case In the following example, I trigger the visibility of a button located next to my breadcrumbs. Depending on what page is shown I want to manipulate the button text and function it triggers.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Breadcrumbs.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button v-if=\u0026#34;button.visible\u0026#34; @click=\u0026#34;$bus.$emit(button.func, true)\u0026#34; class=\u0026#34;btn btn-info d-none d-lg-block m-l-15\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-plus-circle\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; {{ button.text }} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; export default { name: \u0026#39;Breadcrumbs\u0026#39;, data () { return { pageTitle: this.$route.name, button: { visible: false, func: \u0026#39;\u0026#39;, text: \u0026#39;\u0026#39; } } }, mounted () { this.$bus.$on(\u0026#39;breadButton\u0026#39;, data =\u0026gt; { this.button = data }) } } Now you can trigger the button\u0026rsquo;s visibility and action from any of your Vue components.\n1 2 3 4 5 6 7 8 9 10 11 12 export default { mounted () { ... this.$bus.$emit(\u0026#39;breadButton\u0026#39;, { visible: true, text: \u0026#39;New Package\u0026#39;, func: \u0026#39;showOrderPage\u0026#39; }) ... } } In more complex cases, you should consider employing a dedicated state-management pattern. Full documentation\n","date":"2018-03-26T00:00:00Z","permalink":"https://ilyasdeckers.ody.dev/p/vue-create-a-global-event-bus/","title":"Vue.js - Create a global event bus"},{"content":"INTRODUCTION GPU passthrough on Ryzen platform has its issues. The most common one, and the one I struggled with the most was a 10 year old bug. The one we will address today. For those who already tried GPU passthrough on ryzen with KVM, you should have noticed a serious performance drop in your guest vs running your GPU on bare metal. This issue could be adressed by using npt=0. This brought along some other issues like not being able to use host-passthrough, the guest only detecting one core, cpu performance loss,\u0026hellip; Far from ideal. Last week Geoffrey and Paolo managed to patch this bug. In this article we will be applying the patch and compiling it with the latest linux kernel. (4.14-rc8)\nGETTING STARTED You can use almost any kernel with this patch. I have tested this with kernel 4.10, 4.13 and 4.14-rc8. In this guide, I will be using kernel 4.14-rc8. Kernel 4.14 will be released very shortly as of writing. Linus Torvalds noted that this past week of 4.14 development was fairly quiet and perhaps doesn\u0026rsquo;t need an \u0026ldquo;RC8\u0026rdquo; update, but he opted for it anyways. UPDATE: Kernel 4.14 has been released. Click here to learn how to install and update your kernel.\nGetting the kernel First, we will get the build files for the new kernel.\n1 git clone git://git.launchpad.net/~ubuntu-kernel-test/ubuntu/+source/linux/+git/mainline-crack v4.14-rc8 Creating and applying the patch The patch can be found here: https://patchwork.kernel.org/patch/10027525/ or copy and paste the patch to a new file npt-ryzen.patch\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 nano npt-ryzen.patch diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c index af256b786a70..af09baa3d736 100644 --- a/arch/x86/kvm/svm.c +++ b/arch/x86/kvm/svm.c @@ -3626,6 +3626,13 @@ static int svm\\_set\\_msr(struct kvm\\_vcpu \\*vcpu, struct msr\\_data \\*msr) u32 ecx = msr-\u0026gt;index; u64 data = msr-\u0026gt;data; switch (ecx) { +\tcase MSR\\_IA32\\_CR\\_PAT: +\tif (!kvm\\_mtrr\\_valid(vcpu, MSR\\_IA32\\_CR\\_PAT, data)) +\treturn 1; +\tvcpu-\u0026gt;arch.pat = data; +\tsvm-\u0026gt;vmcb-\u0026gt;save.g\\_pat = data; +\tmark\\_dirty(svm-\u0026gt;vmcb, VMCB\\_NPT); +\tbreak; case MSR\\_IA32\\_TSC: kvm\\_write\\_tsc(vcpu, msr); break; Now that we have the patch we can apply it to our kernel.\n1 2 3 cd v4.14rc8 cp /boot/config-$(uname -r) .config patch -p1 \u0026lt; npt-ryzen.patch Compiling the new kernel If all went well, it is time to compile our new patched kernel. Remember, after compiling and installing the new kernel you will have to reboot. Execute the following commands to start compiling the kernel.\n1 2 3 yes \u0026#39;\u0026#39; | make oldconfig make clean make -j 4 deb-pkg LOCALVERSION=-with-npt Note: this process can take up some time.\nInstalling the kernel After the compiling is done you will be left with some .deb files. These are the installation files that we need in order to install the patched kernel.\n1 sudo dpkg -i linux-headers-4.14.0-rc6-custom\\_4.14.0-rc6-custom-1\\_amd64.deb linux-image-4.14.0-rc6-custom\\_4.14.0-rc6-custom-1\\_amd64.deb linux-libc-dev\\_4.14.0-rc6-custom-1\\_amd64.deb At this point you are ready to reboot your machine and your system should be ready for GPU passthrough without any performance loss on your KVM guest.\n","date":"2017-11-19T00:00:00Z","permalink":"https://ilyasdeckers.ody.dev/p/improving-kvm-performance-for-ryzen-with-npt-patch/","title":"Improving KVM performance for Ryzen with the NPT patch"},{"content":"Introduction This tutorial will show how to install the Percona XtraDB Cluster on three Ubuntu 16.04 LTS servers, using the packages from the official Percona repositories. After this tutorial you should be able to install, configure and secure a high available MySQL cluster.\nPrerequisites To follow this tutorial you need 3 machines running Ubuntu 16.04. All machines need to be reachable over SSH and they need to be in the same network.\n1 2 3 4 5 6 7 8 9 10 11 node #1 hostname: mysql01 IP: 10.100.0.200 node #2 hostname: mysql02 IP:10.100.0.201 node #3 hostname: mysql03 IP:10.100.0.202 Configuring the repositories To install Percona XtraDB you will have to add the appropriate repositories to your servers. Run the following commands on the three nodes.\n1 2 3 4 wget https://repo.percona.com/apt/percona-release_0.1-4.$(lsb_release -sc)_all.deb sudo dpkg -i percona-release_0.1-4.$(lsb_release -sc)_all.deb sudo apt-get update sudo apt-get install percona-xtradb-cluster-57 Configure Apparmor \u0026amp; SElinux In order to successfully start Percona XtraDB, it is advised to disable SElinux. When SElinux is enabled the communication between nodes does not work and the nodes won\u0026rsquo;t be able to join the cluster successfully. By default SElinux is not enabled in Ubuntu, if you have installed it previously there are some options for disabling it. To test if SElinux is enabled on your system run the following command.\n1 selinuxenabled \u0026amp;\u0026amp; echo enabled || echo disabled If SElinux is enabled you can completely remove it from your system by uninstalling it\n1 sudo apt-get remove selinux* --purge -y Or you can disable it by editing the config file for SElinux.\n1 SELINUX=disabled Percona doesnâ€™t provide any AppArmor profile for PXC, but it seems that on this server (Ubuntu TLS), a previous version of MySQL was installed and then removed but the AppArmor profile was still present. So if you use apparmor (or if you donâ€™t know) and you want to check is there is a profile for mysql, you can run the following command :\n1 apparmor_status If a mysql profile is available you can disable it like this.\n1 2 sudo ln -s /etc/apparmor.d/usr.sbin.mysqld /etc/apparmor.d/disable/ sudo apparmor_parser -R /etc/apparmor.d/usr.sbin.mysqld If SElinux is enabled you can completely remove it from your system by uninstalling it\nRemember to check all your nodes, it prevents a lot of issues later on.\nConfigure your firewall Percona XtraDB uses some ports asside from the standard 3306. You need to open these ports on your firewall for the cluster to function well.\nMySQL: 3306\nCluster Communication: 4567\nSST: 4568\nThe main cluster communication happens over port 4567. You can change this by specifying this option.\n1 wsrep_provider_options=\u0026#34;gmcast.listen_addr=tcp://0.0.0.0:4010;\u0026#34; Configure the bootstrap node Go to your first node and open /etc/mysql/my.cnf and copy the following configuration at the end of the file and change the IP\u0026rsquo;s on line 2 and 6 to your configuration.\n1 2 3 4 5 6 7 8 9 wsrep_provider=/usr/lib/libgalera_smm.so wsrep_cluster_address=gcomm://10.100.0.200,10.100.0.201,10.100.0.203 # Change the IP\u0026#39;s to your IP\u0026#39;s (ip1,ip2,ip3) binlog_format=ROW default_storage_engine=InnoDB innodb_autoinc_lock_mode=2 address wsrep_node_address=10.100.0.200 # The IP of the node that you are configuring wsrep_sst_method=xtrabackup-v2 wsrep_cluster_name=my_mysql_cluster wsrep_sst_auth=\u0026#34;username:password\u0026#34; # A username and password for SST that we will configure later The first node is ready to be started. Execute the following command to bootsrap the cluster.\n1 /etc/init.d/mysql bootstrap-pxc Now we have to check if the first node has started successfully.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sudo mysql -u root -p mysql \u0026gt; SHOW STATUS LIKE \u0026#39;wsrep%\u0026#39;; +----------------------------+--------------------------------------+ | Variable_name | Value | +----------------------------+--------------------------------------+ | wsrep_local_state_uuid | b598af3e-ace3-11e2-0800-3e90eb9cd5d3 | ... | wsrep_local_state | 4 | | wsrep_local_state_comment | Synced | ... | wsrep_cluster_size | 1 | | wsrep_cluster_status | Primary | | wsrep_connected | ON | ... | wsrep_ready | ON | +----------------------------+--------------------------------------+ 60 rows in set (0.01 sec) As you can see the first node started successfully and it is ready to accept other nodes to join the cluster. Now we have to configure a user to make use of State Snapshot Transfer. Change the username and password to the values you chose for wsrep_sst_auth in /etc/mysql/my.conf.\n1 2 3 mysql\u0026gt; CREATE USER \u0026#39;username\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; mysql\u0026gt; GRANT PROCESS, RELOAD, LOCK TABLES, REPLICATION CLIENT ON \\*.\\* TO \u0026#39;username\u0026#39;@\u0026#39;password\u0026#39;; mysql\u0026gt; FLUSH PRIVILEGES; State Snapshot Transfer (SST) is a full data copy from one node (donor) to the joining node (joiner). Itâ€™s used when a new node joins the cluster. In order to be synchronized with the cluster, the new node has to receive data from a node that is already part of the cluster.\nConfigure the two other nodes Edit /etc/mysql/my.cnf on the two other nodes. Remember to change the IP of the host on line 6.\n1 2 3 4 5 6 7 8 9 wsrep_provider=/usr/lib/libgalera_smm.so wsrep_cluster_address=gcomm://10.100.0.200,10.100.0.201,10.100.0.203 # Change the IP\u0026#39;s to your IP\u0026#39;s (ip1,ip2,ip3) binlog\\_format=ROW default_storage_engine=InnoDB innodb_autoinc_lock_mode=2 address wsrep\\_node_address=10.100.0.200 # The IP of the node that you are configuring wsrep_sst_method=xtrabackup-v2 wsrep_cluster_name=my_mysql_cluster wsrep_sst_auth=\u0026#34;username:password\u0026#34; # The username and password for SST Then start MySQL on the nodes.\n1 sudo service mysql start If everything went right, you can check the cluster status to check if all nodes are connected and the cluster is in a good state.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sudo mysql -u root -p mysql\u0026gt; SHOW STATUS LIKE \u0026#39;wsrep%\u0026#39;; +----------------------------+--------------------------------------+ | Variable_name | Value | +----------------------------+--------------------------------------+ | wsrep_local_state_uuid | g4fd322e-whe3-11e2-0255\\3e90eb9cd5d3 | ... | wsrep_local_state | 4 | | wsrep_local_state_comment | Synced | ... | wsrep_cluster_size | 3 | | wsrep_cluster_status | Primary | | wsrep_connected | ON | ... | wsrep_ready | ON | +----------------------------+--------------------------------------+ 40 rows in set (0.01 sec) Conclusion Setting up a Percona XtraDB cluster is relatively easy. There are however some things that could go wrong. 90% of the time it has something to do with SElinux. A whole other beast is when your cluster dies, there are a lot of scenario\u0026rsquo;s that could break the cluster. I will get more in depth in a later article.\nTIP: In case of any errors look for the file /var/lib/mysql/mysqlxx.err this file has saved me in a lot of situations when troubleshooting MySQL.\n","date":"2017-03-14T00:00:00Z","permalink":"https://ilyasdeckers.ody.dev/p/building-high-available-mysql-cluster-with-percona-xtradb/","title":"Build a High Available MySQL Cluster with Percona XtraDB and Ubuntu 16.04"}]